# 리눅스 실무의 이해

## 1. 리눅스 개요

### 1.1 운영체제의 개요

#### 1.1.1 운영체제 정의 및 목적, 역할

- 정의 : 하드웨어 조작을 위한 사용자 인터페이스

- 목적 : 처리 능력 향상, 반환 시간 최소화, 신뢰도 향상, 가용성 확장

- 역할 : 하드웨어 리소스 관리

#### 1.1.2 운영체제 구조와 기능

- 구조 : 시스템 기능 호출을 위해 응용 프로그램, shell 등을 사용할 수 있는 하드웨어 추상계층 제공

- 기능 : 프로세스, 메모리, 장치 I/O, 파일시스템, DB, 네트워크 등 자원 및 접근 관리

#### 1.1.3 운영체제 운용 기법 및 발전 순서

- 일괄 처리(Batch System) : 여러 작업을 한번에 묶어서 처리함. 처리 중에는 I/O Blocking 발생하고 현재 이외 다른 작업 수행을 Blocking 발생

- 다중 프로그래밍(Multi Programming System) : I/O Blocking 시 다른 작업을 수행하는 Non-Blocking 기법

- 시분할(Time Quantum System) : 여러 작업을 일정 Time Quantum으로 번갈아가며 수행하는 기법(동시성 확보)

- 다중 처리(Multi Processing System) : 여러 개의 프로세스를 통해 여러 작업을 동시에 수행하는 기법(병렬성 확보)

  - 다중 처리는 비대칭적(주-종 프로세스) 및 대칭적 다중처리로 나뉜다.

- 실시간 처리(Real Time System) : 요구된 시간 안에 작업을 실행하는 기법
  - soft real time, hard real time processing

- 다중 모드(Multi-Mode System) : 위의 방식을 모두 혼용해서 사용하는 기법

- 분산 처리(Distributed Processing System) : 독립적인 시스템 간의 통신을 통해 작업을 분산하여 처리하는 기법

#### 1.1.4 운영체제 사례

- 리눅스는 데스크톱, 서버, IoT에 사용되는 운영체제

- 경량형 운영체제 : Contiki, TinyOS, RIOT

- 모바일 운영체제 : Tizen(삼성전자 & 인텔), raspbian, webOS(LG 개발 IoT용)

### 1.2 리눅스 기초

#### 1.2.1 리눅스 개요

##### 1.2.1.1 정의와 의미

- 정의 : 개인용 데스크톱, 서버, 모바일 기기, 임베디드 기기 등에 사용되는 오픈소스 운영체제

##### 1.2.1.2 리눅스 일반적 특징

- 이식성(Portablility) : 여러 CPU 플랫폼에 적용 가능

- 자유 소프트웨어(free software) : 오프소스 운영체제로 여러 개발자들이 기여 중

- 멀티 유저(multi-user) : 다양한 사용자가 시스템 리소스에 접근 가능

- 멀티 프로그래밍(multi-programming) : 다양한 작업을 동시에 실행 가능

- 계층적 파일 시스템(hierarchical file system) : 루트 디렉토리(/) 하위에 사용자 관련 디렉토리(/usr), 디바이스 관련 디렉토리(/dev) 등이 있음

- 쉘(shell) : 리눅스 명렁어 실행 프로그램. 명령어 해석, 프로그래밍, 환경설정 기능을 제공함

- 보안(security) :
  - 주체(사용자)에 객체(디렉토리 및 파일) 접근 권한을 부여하는 **임의 접근 제어**(접근 통제 모델) 정책 제공
  - 리눅스 자체를 네트워크 노드 및 라우터로 활용할 수 있음. **netfilter, iptables, ebtables, arptables** 제공
  - 주체(사용자)와 객체(디렉토리 및 파일)에 각각 권한 레벨을 부여하여 주체가 객체보다 레벨이 높거나 낯을 때만 접근할 수 있는 **강제 접근 제어** 제공

##### 1.2.1.3 리눅스 기술적 특징

- 모놀리틱 커널(Monolithic kernel) : 단일 커널로 리소스(CPU, 메모리 등) 관리 기능을 제공함
  - 일부 기능 변경 시, 커널 전체를 컴파일 해야하는 단점도 있으나 동적 설정이 가능한 커널 모듈도 존재함

- 장치의 파일화 : 모든 시스템 자원을 파일로 관리함. 디렉토리, 일반파일, 특수파일(장치 파일, 파이프, 소켓)로 나뉨
  - 장치 파일 : 문자 장치 파일 / 블록 장치 파일
  - 파이프 : 프로세스 간 통신을 위해 존재하는 파일
  - 소켓 : 응용 프로그램간 소켓 프로그래밍을 위해 존재하는 파일

- 다양한 파일 시스템 지원
  - 리눅스 자체 파일 시스템 : ext2, 3, 4
  - 윈도우 파일 시스템 : FAT32, NTFS
  - 네트워크 파일 시스템 : SMB, CIFS
  - 복구용 파일 시스템 : 저널링 파일 시스템

- 가상 메모리 : 물리적인 메모리 크기로 인한 한계를 극복하기 위한 기법
  - 자주 사용하는 프로그램을 물리 메모리에 로드하고, 그렇지 않은 것은 디스크에 저장하는 페이징 기법 사용
  
- 스왑(Swap)
  - 메모리에서 자주 사용되지 않은 것을 swap-out할 때 사용되는 디스크 공간(일명 swap space)
  - 휘발성 메모리 데이터를 비휘발성 디스크에 저장함
  - **/etc/sysctl.conf에서 vm.swapiness**에 swap 사용 여부 설정함. 만약 10으로 설정되어 있으면 메모리가 10% 사용될 때 swap을 시작함
  - **free 명령어**로 swap space 및 메모리 사용량 확인 가능
  - swap space 크기는 동적으로 변경이 **불가능**함
 
- 정적 라이브러리와 동적 라이브러리
  - 정적 라이브러리 : 프로세스마다 로드하며, 실행 속도가 빠르고 크기가 크며 배포에 제약이 없음 
  - 동적 라이브러리 : 프로세스끼리 공유하며, 실행 속도가 느리고 크기가 작으며 배포에 제약이 있음
      - /etc/ld.so.conf 파일과 환경변수 LD_LIBRARY_PATH를 확인하여 동적 라이브러리 로드
      - /etc/ld.so.cache 파일을 활용하여 빠른 동적 라이브러리 검색 가능(conf 파일 변경시 ldconfig로 캐시 업로드 필요)

- 파이프 : 프로세스의 표준 출력을 다른 프로세스로 보내기을 위해 사용(|)

- 라다이렉션 : 프로세스 입력 및 출력 (<<, >>)

##### 1.2.1.4 리눅스 장단점

오픈 소스의 장단점과 동일함

#### 1.2.2 리눅스와 GNU 그리고 오픈소스 라이센스

- GNU GPL(General Public License)는 자유 소프트웨어에 배포되는 라이센스이다. GPL 라이센스가 있는 소프트웨어를 사용하는 다른 소프트웨어는 GPL 라이센스 배포가 필요하다.

- 리눅스는 유닉스의 POSIX 표준을 따르나 소스코드는 일체 사용하지 않았다. 리눅스 또한 GNU GPL 라이센스에 등록되어 있다.

- copyleft 라이센스

- GPL 이외의 다양한 오픈소스 라이센스
  - LGPL : LGPL 프로그램을 사용하는 소프트웨어는 LGPL 라이센스가 해당되지 않으나, 소스코드를 수정한 경우에는 LGPL 라이센스에 해당됨
  - BSD : 버클리 대학교 오픈소스 라이센스. 2차 저작물은 재배포 및 소스 공개가 의무가 아님
  - 아파치 라이센스 : 2차 저작물을 상업적 목적으로 사용할 수 있음. 단, 아파치 라이센스를 따른다고 명시해야함
  - MPL 라이센스
  - MIT 라이센스 : 라이센스 및 저작권만 명시하면 무엇이든 사용 가능

#### 1.2.3 리눅스의 역사와 리눅스 배포판

##### 1.2.3.1 리눅스 역사

##### !.2.3.2 리눅스 분류 및 특징

- 슬렉웨어 : 가장 오래된 배포판
- 데비안 : 자발적 커뮤니티에 의한 배포판
  - 우분투
  - raspbian
  - chromeOS
- 레드햇 : 유료서비스를 통한 수익 창출 추구.
  - centOS : 단, centOS는 개인 사용자에게 무료로 배포됨(apt)
  - Fedora

***

## 2. 리눅스 시스템 이해

### 2.1 리눅스와 하드웨어

#### 2.1.1 하드웨어의 이해

##### 2.1.1.1 컴퓨터의 구성요소

- 중앙처리장치(CPU) : 레지스터(연산을 위한 임시 저장소), 연산장치, 제어장치
- 주기억장치(Main Memory) :
  - RAM : 휘발성이나 주소를 따라 시간상 동일하고 빠르게 접근 가능
  - ROM : 비휘발성이며 BIOS(컴퓨터 부팅용)같은 프로그램이 적재됨
    - MASK : 수정 불가
    - PROM : 1회 수정 가능
    - EPROM : 계속해서 수정 가능
- 입출력장치
- 보조기억장치 : 주기억장치 대비 속도가 느림. SSD, DVD 등

##### 2.1.1.2 리눅스 설치를 위한 하드웨어 요구사항

- 중앙처리장치(CPU) : GNU C가 지원하는 CPU 환경이면 리눅스 이식 가능
- 보조기억장치(RAM) : 대부분 모두 지원(32bit, 64bit 운영체제)
- 하드디스크 : 대부분 지원하며 **/dev/sdX** 파일에 매핑됨
- 그래픽카드 : 대부분 지원하며 **lspci** | grep -I vga 명령어로 확인 가능
- 랜카드 및 주변장치 : 대부분 모두 지원

#### 2.1.2 하드웨어 선택

##### 2.1.2.1 RAID 개요

- 복수의 디스크의 고성능 및 신뢰성(무정지)을 위해 중복된 데이터를 나눠서 저장하는 기술이다. 1개의 RAID는 운영체제에서 1개의 디스크로 인식됨
- RAID 0는 고성능을 추구하고, RAID 1은 무정지를 추구함
- 스트라이핑 기술 : 고성능을 위해 연속된 데이터를 여러 디스크에 라운드 로빈으로 저장함
- 미러링 기술 : 무정지를 위해 하나 이상의 장치에 중복하여 데이터를 저장함

##### 2.1.2.2 RAID 종류

- RAID 0 : 스트라이핑 기술을 적용하여 처리속도가 빠름. 그러나, 에러 발생 시 복구가 불가능함.
- RAID 1 : 미러링 기술을 적용하여 읽기속도가 빠름. 그러나, 중복 저장 때문에 처리 속도가 중복된 정도에 따라 줄어듦.
- RAID 2 : 비트 레벨로 스트라이핑 기술을 적용함. 오류 정정 부호를 저장하여 복구도 가능함. 그러나, 추가 비트연산이 필요하므로 입출력 성능이 떨어짐
- RAID 3 : 바이트 레벨로 스트라이핑 기술을 적용함. 패리티 디스크를 통해 오류 체크 및 복구 가능. 쓰기 및 읽기 성능 모두 우수함
- RAID 4 : 블록 레벨로 스트라이핑 기술을 적용함.
- RAID 5 : 블록 레벨로 스트라이핑 기술을 적용하나, 패리티 디스크가 따로 존재하지 않음(가장 많이 사용)
  - 디스크 개수를 늘릴수록 저장공간 효율성이 증가함
- RAID 6 : 2개의 패리티를 사용하여 2개의 디스크 오류에도 데이터를 읽을 수 있고 최소 4개 디스크 필요
- RAID 0+1 : RAID 0 구성 세트에 RAID 1을 적용  
- RAID 1+0 : RAID 1 구성 세트에 RAID 0을 적용

##### 2.1.2.3 디스크 인터페이스
- IDE : 병렬 인터페이스. PATA라고도 불림
- SATA : 직렬 인터페이스
- SCSI : 병렬 인터페이스
- SAS : 병렬 인터페이스


##### 2.1.2.4 LVM

- 디스크와 파일 시스템의 중간 장치로, 파일을 디스크에 저장할 때 LVM이 매핑한 Logical Volume에 저장하도록 함.
- LVM 구성도
  - VG(Volume Group) : 여러 PV를 갖는 그룹. PV와 VG는 N:1 관계
  - PV(Physical Volume) : 기존 물리적 디스크를 LVM에서 사용할 수 있도록 논리적으로 분할한 개념(ex. /dev/sda3, /dev/sdc1)
  - PE(Physical Extent) : 일정한 크기의 블록(4MB). PE와 PV 는 N:1 관계
  - LV(Logical Volume) : VG에서 필요한 만큼 할당하여 만들어지는 공간(ex. /usr, /home)
  - LE(Logical Extent) : 일정 크기의 블록(4MB). LE와 LV는 N:1 관계. LE와 PE는 1:1 관계

 
### 2.2 리눅스 구조

#### 2.2.1 부트 매니저

- 보조기억장치에 존재하는 운영체제를 주기억장치에 로드하기 위한 프로그램
- 대표 부트 매니저 : LILO(가장 오래됨), GRUB(대화형 인터페이스), GRUB2

#### 2.2.2 주요 디렉토리 구조

- 리눅스 주요 디렉토리
  - /bin :   사용자 주요 명령어 (cd, ls)
  - /boot :   부팅에 필요한 파일 위치
  - /dev :   디바이스 파일이 위치
  - /etc :   시스템 환경변수 및 시스템 초기화(부팅) 시 사용하는 스크립트
  - /home :   로그인 사용자 파일
  - /lib :   시스템 라이브러리
  - /media :   CD-ROM 등 이동식 디스크
  - /mnt :   디바이스 마운트 시 사용하는 임시 디렉토리
  - /opt :   애플리케이션 소프트웨어 패키지
  - /proc :   메모리에 존재하는 프로세스들이 파일로 저장됨. 프로세스 상태 정보, 하드웨어 정보 등 존재
  - /root :   루트 사용자 디렉토리
  - /sbin :   시스템 주요 명령어
  - /var :   로그, 스풀 등 저장(ex. /var/log)
  - /sys :   장치 정보 제공
  - /run :   프로세스 런타임 데이터 저장

#### 2.2.3 부팅과 셧다운

##### 2.2.3.1 부팅 개요
- 부팅 : BIOS는 MBR(Master Boot Record. 하드디스크 0번 섹터)로부터 부트 로더를 실행함

##### 2.2.3.2 부팅 절차
- 부팅 절차 :
  - 시스템 시작 및 하드웨어 초기화
  - 1단계 부트로더 : MBR(0번 섹터. 512 bytes)에 존재. 공간이 부족하므로 파일 시스템을 해석할 수 있는 기능이 없으므로 1.5단계 부트로더로 점프할 기능만 제공
  - 1.5단계 부트로더 : 파일 시스템 드라이버 포함. 2단계 부트로더로 점프
  - 2단계 부트로더 : 파일 시스템에 존재. 부트 매니저에 따라 운영체제를 선택하고, 운영체제를 위한 커널을 메모리에 로드하고 커널에 제어권 전달
  - 커널 : /sbin/init 또는 심볼릭 링크 /usr/lib/systemd/systemd 실행하여 init 프로세스 실행
  - INIT 프로세스 : centOS6에서 /etc/inittab 파일을 읽어서 적절한 시스템 스크립트(/etc/rcㅁ.d)실행
    - run level : 0-종료, 1-단일 사용자(복구용), 2-다중 사용자, 3-네트워크 기능 포함한 다중 사용자, 5-X 윈도우 다중 사용자, 6-시스템 재부팅
  - systemd : .target 파일을 실행하고. run level은 INIT 프로세스와 유사함
  - 사용자 프롬프트

##### 2.2.3.3 로그인, 로그아웃, 시스템 종료
- 로그인 공지 기능
  - /etc/issue : 로컬에서 로그인 시도 시, 로그인 전 해당 메세지 출력
  - /etc/issue.net : 원격으로 로그인 시도 시, 로그인 전 해당 메세지 출력
  - /etc/motd : 로그인 성공 후, 해당 메세지 출력

- 로그아웃 : logout 명령어 또는 ctrl + d로 가능
  - /etc/profile에서 TMOUT을 설정하여 자동 로그아웃 가능
  - source /etc/profile 커맨드 시 즉시 실행 가능

- 종료 : shutdown -h [+minutes] 으로 종료 가능
  - shutdown -r [+minutes]으로 재부팅 가능

##### 2.2.3.4 GRUB Legacy 패스워드 설정 및 복구
- 부트로더 실행시 사용하는 패스워드와 관련된 내용
- 패스워드 설정 : /boot/grub/grub.conf
```shell
  # grub-crypt 명령어로 encoded password 생성 후 아래 추가
  hiddenmenu
  password --encrypted [SHA-256, 512 encoded password]


  또는

  # md5-crypt 명령어로 encoded password 생성 후 아래 추가
  hiddenmenu
  password [my password]
```
- 패스워드 복구
  - root 계정 접근 가능 : 위 설정에서 password 삭제
  - root 계정 접근 불가능 : 부팅 메뉴에서 Rescued Install System -> /mnt/sysimgage/boot/grub/grub.conf 수정
##### 2.2.3.5 GRUB2 Legacy 패스워드 설정 및 복구
- GRUB Legacy와 유사함... 추후 확인

#### 2.2.4 systemd
##### 2.2.4.1 개요
- 시스템과 관련된 서비스를 제공하는 매니저
##### 2.2.4.2 구조
- 유닛
  - .service : 시스템 상에 동작하는 서비스 또는 데몬과 연관된 유닛
  - .target : 다수의 유닛을 하나의 그룹으로 관리할 수 있는 유닛 (ex. 부팅 시 사용하던 .target 파일)
  - .device : 주변기기 장치와 관련된 유닛. 예를 들어, USB가 연결되었을 때 특정 서비스 유닛을 실행하도록 함
  - .mount : 파일 시스템의 마운트 포인트를 나타내는 유닛
  - .path : 파일 시스템의 파일과 디렉토리와 연관된 유닛
  - .socket : 프로세스간 통신을 위해 사용하는 소켓과 관련된 유닛
  - .timer : systemd 타이머과 관련된 유닛

- 유닛 파일 구조
  - [Unit]
  - [Unit Type]
  - [Install]
##### 2.2.4.3 주요 명령어
- 서비스 관리
- 타겟 유닛
- 전원 관리

#### 2.2.5 파일 시스템의 이해
##### 2.2.5.1 개요
- 데이터를 레코드 및 블록 단위로 저장하고 캐시 기능도 지원함
##### 2.2.5.2 리눅스 파일 시스템 구조
- 부트섹터
- 블록그룹
  - 슈퍼블록
  - 그룹 디스크립터 테이블
  - 블록 비트맵
  - 아이노드 비트맵
    - 아이노드 : 실제 파일 및 디렉토리 정보를 저장한 자료
    - 파일과 디렉토리는 아이노드를 갖고 있고, 아이노드가 실제로 데이터 주소를 찾음.
  - 아이노드 테이블 : EX. ex2 방식
  - 디렉토리, 데이터 블록
- 로컬 파일 시스템
  - ext, ext2, ext3, ext4, btrFS, ZFS, Reisefs, XFS(CentOS 7 기본 탑재. b-tree 알고리즘), JFS
- 클러스터 파일 시스템
  - OCFS, Raw Partitions

### 2.3 X 윈도우
#### 2.3.1 X 윈도우 개념
- 유닉스 및 리눅스 접속을 위한 독립적 윈도우 시스템
- 일반적인 서버-클라이언트 모델을 사용하므로 X 프로토콜을 준수할 수 있는 시스템에는 X 윈도우 이식 가능
#### 2.3.2 X 윈도우 구조
- X 서버, X 클라이언트
- X 프로토콜 : Request, Reply, Event, Error
- Xlib, XCB : X 윈도우 시스템 프로토콜 클라이언트 라이브러리
- XToolkit : GUI 개발 kit. 그래픽 요소는 다른 라이브러리로 구현
#### 2.3.3 XFree86, X.org
- X 윈도우 프로젝트
#### 2.3.4 X 윈도우 계층
- X 서버 : X 서버, 디스플레이 매니저(그래픽 유저 인터페이스 제공)
- X 클라이언트 : 어플리케이션, 데스크톱 환경, 윈도우 매니저(X 윈도우 그래픽 요소(X 윈도우 표현 및 배치) 관리)
#### 2.3.5 데스크톱환경 구성 사례
#### 2.3.6 X 윈도우 실행
- CentOS6
  - /etc/inittab 에서 run level을 5로 변경
- CentOS7
  - systemctl 명령어로 변경
```shell
  systemctl set-default runlevel5.target(graphical.target) 
```
- xhost + : 특정 또는 모든 클라이언트 접속 허용
- xhost - : 특정 또는 모든 클라이언트 접속 차단



### 2.4 셸(Shell)
#### 2.4.1 셸의 이해
##### 2.4.1.1 셸의 개념
- 셸 :  커널 서비스를 사용하기 위한 사용자 인터페이스
##### 2.4.1.2 셸의 유형
##### 2.4.1.3 셸의 설정 및 확인
- 현재 셸 확인 : ```echo $SHELL```
- 지원하는 셸 목록 확인 : ```cat /etc/shells```, ```chsh -l```
- 셸 변경 : ```chsh -s [/bin 하위 shell]```
- 특정 사용자의 셸 확인 : ```cat /etc/passwd | grep [사용자 이름]```
- 환경변수 확인 : ```set```
- 현재 셸에 export된 변수 확인 : ```env```
- 특정 환경변수 확인 : ```echo $[환경변수명]```, ```printenv [환경변수명]```
- 특정 환경변수 설정 : ```export [환경변수명]=...```
##### 2.4.1.4 셸의 시작과 종료
##### 2.4.1.5 셸의 기능
- 자동완성 : TAB
- 히스토리 : ```history```
- 가장 최근 n개 히스토리 : ```history n```
- 히스토리 제거 : ```history -c```
- 히스토리의 n번째 명령어 실행 : ```!n```
- 직전 명령어 실행 : ```!!```
- alias 조회 : ```alias```
- alias 설정 : ex. ```alias ll="ls -lia"```
- 명령어 치환 기능 :  ex. ```touch $(date)```
- 산술 평가 기능 : ex. ```$((2+3))```
  - 명령어 치환과 산술 평가 차이에 주의할 것
- 셸 키보드 단축키
- 표준 입출력 : stdin-0, stdout-1, stderr-2
- 리다이레션 : 전체 입출력-<,> 버퍼에 추가하며 입출력-<<,>>
```shell
# example : 어떤 의미인지 알아볼 것
sort < list.txt
find /tmp -name `good*' 2>error.log
invalid-command 2>/dev/null
ls exist-dir not-exist-dir > result 2>&1
```
- 파이프 : ```|```
- tee : 표준 입력으로 데이터를 받아 표준 출력하거나 파일 저장을 동시에 할 수 있는 명령어
```sh
tee file # 표준출력과 동시에 file에 저장함
ping google.com -c 1 | tee -a result.txt
ping google.com | tee result.txt
```
- 그룹 연산자
```sh
ls ; echo "second" # ;는 순차적으로 명령어를 실행
ls || echo "second" # ||는 앞의 명령이 성공하면 종료. 실패하면 그 다음을 실행함
ls && echo "success" # &&는 앞의 명령어가 성공하면 이후 명령어를 실행함
$(date; pwd; ls) > result.txt
```
- 산술 논리 연산 : expr ex. ```expr 1 \* 3```
  - length, substr도 지원함
  - 메타문자(ex. *)는 escape가 필요함
- 작업 제어 기능 : 백그라운드 실행-&
- 내부 명령어
  - 변수 : let, eval, set, unset, export
  - 스크립트 : source(현재 셸에서 스크립트로 실행), exec(fork하지 않고 현재 프로세스에서 실행), bash(새로운 프로세스로 실행), exit
    - './', 'bash' 명령어가 새로운 프로세스를 생성하여 셸을 실행함


#### 2.4.2 셸 프로그래밍
##### 2.4.2.1 개요
- 셸 스크립트를 작성하는 활동
- 셸 스크립트 형식
```sh
#! /bin/bash # 사용할 shell 선택
# 이하 원하는 셸 스크립트 기술
echo "hello world!"
```
- 별도 프로세스로 셸 스크립트 실행 : ```./[script.sh] ``` 단, 실행 권한이 있어야 함
  - ./를 붙이는 이유는 셸은 기본적으로 환경변수에 지정된 PATH에서만 파일을 찾기 때문임
  -  ```bash script.sh```와 동일함
  -  ```. script.sh```는 새로운 셸에서 실행함
##### 2.4.2.2 기본 문법
- 주석 : ``` # 으로 주석 ```
- 변수
```sh
#! /bin/bash
name="hong gil dong"
echo $name
echo "\${name} =${name}"
echo "length=${#name}" # 문자열 길이
echo "offset=${name:5}"
echo "length from offset=${name:5:3}"
echo "\${name} =${name+HELLO}" # name이 null이 아니면 HELLO 반환. 그러나, 변수에 저장하지는 않음
echo "\${name} =${name-HELLO}" # name이 null이면 HELLO 반환. 그러나, 변수에 할당하지는 않음
echo "\${name} =${name?HELLO}" # name이 null이 아니면 name을 반환. 그렇지 않으면 HELLO 반환
```
- 위치 매개변수
```sh
cp org.txt tgt.txt # $0-cp, $1-org.txt, $2-tgt.txt
# '#@'는 입력된 매개변수를 순서대로 보관함
# '$*'는 입력된 매개변수를 하나의 스트링으로 보관함 
``
- echo와 특수문자
```sh
#!/bin/bash
echo -e "hello\nworld"
echo -e "hello\tworld"
echo -e "hello\bworld" # backspace
echo -e "hello\fworld" # formfeed
echo -e "hello\rworld" # carriage-return
echo -e "hello\\world"
```
- 조건식
  - 숫자 : -eq -gt -ge -lt -le -ne ! -a -o
  - 문자열 : = != < > -n -z
  - 파일 : -b -c -d -e -x -r -w -f -g
```sh
[ 2 -gt l]
echo $?
```
- if-elif-else 조건문
```sh
#!/bin/bash
if [ "$1" -gt 2 ]
then 
	echo "greater than 2"
elif [ "$1" -gt 1 ]
then
	echo "greater than 1"
else
	echo "less then 1 or equal to 1"
fi
```
- case 조건문
```sh
#!/bin/bash
NOW=$(date +"%a")
#NOW="Mon"
case $NOW in
	Sat|Sun)
		echo "it is weekend!";;
	*)
		echo "not weekend...";;
esac
```
- 반복문
```sh
for i in 1,2,3,4,5
do
	echo "Looping $i"
done
```
```sh
while 표현문
do
	명령문
done
```

- 선택문
```sh
#!/bin/bash
select menu in who whoami quit
do
	case $menu in 
		who) echo "who";;
		whoami) echo "whoami";;
		quit) break;;
	esac
done
```
```
1) who
2) whoami
3) quit
#? 1
who
```

- 함수 선언
```sh
#!/bin/bash
factorial() {
  if [ $1 -eq 1 ]
  then
    echo 1
  else
          local sub_result=$(( $(factorial $(($1 - 1))) ))
    echo $(( $1 * sub_result ))
  fi
}

result=$(factorial $1)
echo "result: $result"
```

- 문자열 제거
```sh
STR="ABC123abc123ABC"
echo "${STR#A*1} # 맨 앞부터 A로 시작해서 1로 끝나는 문자열 중 가장 짧은 것을 제거
echo "${STR##A*1} # 맨 앞부터 A로 시작해서 1로 끝나는 문자열 중 가장 긴 것을 제거
echo "${STR%A*1} # 맨 뒤부터 A로 시작해서 1로 끝나는 문자열 중 가장 짧은 것을 제거
echo "${STR%%A*1} # 맨 뒤부터 A로 시작해서 1로 끝나는 문자열 중 가장 긴 것을 제거
```

### 2.5 프로세스
#### 2.5.1 프로세스 개요
##### 2.5.1.1 프로세스 개념
- 정의 : 실행 중인 프로그램 인스턴스
##### 2.5.1.2 프로세스 유형
- 최상위 프로세스 : CentOS 6-/sbin/init, CentOS 7-/usr/lib/systemd/systemd
- 부모 프로세스와 자식 프로세스 : fork
- 고아 프로세스 : 부모 프로세스가 종료된 경우. 고아 프로세스의 부모는 init 프로세스
- 좀비 프로세스 : 부모 프로세스가 자식 프로세스를 회수할 때, 리소스는 회수했지만 프로세스 테이블에서 삭제되지 않은 경우
- 데몬 : 자동으로 실행되며 백그라운드에서 이벤트 핸들링을 하는 프로세스(ex. 파일전송, 프린터, 원격접속 등)
##### 2.5.1.3 프로세스 식별자
- PID, PPID, UID(GID)
#### 2.5.2 프로세스 동작원리
##### 2.5.2.1 프로세스 생성
- fork를 통해 부모 프로세스를 복제하여 자식 프로세스를 생성하고, exec를 통해 자식 프로그램으로 교체됨
- exit가 호출하면 부모 프로세스는 wait 시스템 콜을 통해 자식 프로세스 코드 회수
##### 2.5.2.2 프로세스 제어
- 포어 그라운드 프로세스 : 새롭게 시작되는 프로세스로 실행되는 동안 셸을 block함
- 백 그라운드 프로세스 : 백그라운드에서 프로세스 실행. 실행 명령어 뒤에 &를 붙여서 백그라운드 모드로 실행 가능
- 포어그라운드-백그라운드 전환
  - 포어그라운드 -> 백그라운드 전환 : ctrl+z로 중지된 프로세스를 ```bg```명령어로 백그라운드 실행 가능(```jobs```명령어로 현재 백그라운드 실행 프로세스 확인 가능)
  - 백그라운드 -> 포어그라운드 전환 : ```fg %1```
##### 2.5.2.3 프로세스 중지
- ctrl+c, kill
- 시그널 : 프로세스가 다른 프로세스에 신호를 주는 방식. kill -l
  - SIGHUP(1) : 터미널 접속 끊김
  - SIGINT(2) : ctrl+c로 인터럽트 발생
  - SIGQUIT(3) : ctl+\ 입력
  - SIGKILL(9) : 프로세스 강제 종료
  - SIGTERM(15) : 프로세스 정상 종료
  - SIGCONT(18) : 프로세스 재개
  - SIGSTOP(19) : 프로세스 중지
  - SIGTSTP(20) : 프로세스 대기를 위해 ctl+z 입력
##### 2.5.2.4 프로세스 상태
##### 2.5.2.5 프로세스 구조
- PCB(Process Control Block) : 프로세스 스케줄링 시, 프로세스의 상태 정보 등을 관리하는 커널에 존재하는 테이블
  - 프로세스당 1개의 PCB를 갖음.
- 프로세스 테이블 : 모든 프로세스를 관리하는 테이블
#### 2.5.3 데몬
##### 2.5.3.1 실행방식
- standalone : 시스템 시작 시 즉각 백그라운드 실행. 응답성은 좋으나 효율성이 떨어짐
  - CentOS 6 - /etc/rc.d/init.d
  - CentOS  /etc/systemd/system
- xineted : 사용자 요청이 있을 때 마다 실행
- systemd on-demand 방식 : xineted와 동일하게 CentOS 7에서 동작
##### 2.5.3.2 데몬 시작
- CentOS 6 : /etc/rc.d/init.d 에 시작 스크립트 존재
- CentOS 7 : systemd 유닛 단위로 실행
  - 원하는 타겟 실행 시, 데몬이 실행되도록 할 수 있음 (ex. systemctl enable httpd.service)
##### 2.5.3.3 데몬 설정 도구(CentOS 6)
- ntsys, chkconfig, system-config-services
##### 2.5.3.4 데몬 설정 도구(CentOS 7)
- systemctl, systemd-cgtop(cgroup에 속한 데몬 설정), systemd-cgls, systemd-analyze
  - cgroup : 애플리케이션 단위로 리소스 자원 관리


***

## 3. 네트워크의 이해
### 3.1 네트워크 기초
#### 3.1.1 OSI 7 계층
##### 3.1.1.1 OSI 7 계층 개요
- 정의 : 국제표준화기구(ISO)에서 컴퓨터 네트워크 프로토콜 디자인과 통신 계층을 구성하여 개발한 네트워크 모델
##### 3.1.1.2 OSI 7 계층 세부 설명
- 계층 : 물리 -> 데이터링크 -> 네트워크 -> 전송 -> 세션 -> 프레젠테이션 -> 응용
  - 물리 계층 : BlueTooth와 같은 물리적 연결.(허브, 리피터)
  - 데이터링크 계층 : 프레임 단위로 데이터 전송. 각 노드는 MAC 물리 주소를 가짐(bridge, switch)
  - 네트워크 계층 : 패킷 단위로 데이터 전송. 각 노드는 ip 논리적 주소를 가짐(라우터)
  - 전송 계층 : 세그먼트 단위로 데이터 전송. 각 노드는 port 번호를 가짐
  - 세션 계층 : 메세지 단위로 데이터 전송. 세션 연결을 통한 동기적 통신(SSL, TLS)
  - 표현 계층 : 메세지 단위로 데이터 전송. 어떤 방법으로 데이터를 해석할 것인지 결정
  - 응용 계층 : 메세지 단위로 데이터 전송. 애플리케이션 서비스 제공
#### 3.1.2 네트워크 장비
##### 3.1.2.1 LAN 구성 장비
- 네트워크 인터페이스 카드 : 물리 및 데이터링크 계층 기능 수행 및 MAC 주소 제공
- 케이블
- 허브 : 다수의 장치를 LAN에 접속하도록 하여 하나의 장비에서 전송한 메세지를 다른 쪽에서도 받을 수 있게 함(star 구조)
##### 3.1.2.2 인터네트워크 장치
- 리피터 : 물리 계층 장치로 신호를 증폭함
- 브리지 : 데이터링크 계층 장비로 MAC 주소에 따라 데이터를 전달함
- 라우터 : 네트워크 계층 장비로 라우팅 테이블을 통해 데이터를 효율적으로 전달함
- 게이트웨이 : 서로 다른 프로토콜 및 통신망을 연결하기 위해 이종 프로토콜 변환 기능을 수행하는 장비
#### 3.1.3 데이터 통신의 기본 이해
##### 3.1.3.1 네트워크 토폴로지
- 스타형 : 중앙 노드와 사용자 노드가 point-to-point 방식으로 연결. 보통 중앙 노드가 허브 역할을 함(연결이 많아질수록 패킷 충돌할 수 있음)
- 버스형 : 단일 회선에 여러 사용자 노드가 연결됨. 한 사용자가 점유하면 다른 사용자는 이를 사용할 수 없음
- 링형 : 원형으로 회선이 구성되어 앞 노드가 데이터를 받으면 뒤 노드가 이를 전달받음
- 망(mesh)형 : 그물처럼 연결된 네트워크 구조. 가용성과 효율성이 높음
##### 3.1.3.2 네트워크 통신방식
- 이더넷 : LAN, MAN, WAN 구축을 위해 사용되는 네트워크 기술
  - CSMA/CD : 채널에 다른 것이 감지되지 않으면 데이터를 보내고, 충돌이 감지되면 일정시간 뒤 다시 보내는 기술
- 토큰링
- FDDI
##### 3.1.3.3 네트워크 유형
- LAN : 지역 네트워크에서 자유로운 데이터 교환 네트워크 
- MAN : 도시 통신망
- WAN : 광역 통신망. 전용 회선 방식과 교환 회선 방식 존재
##### 3.1.3.4 교환 방식
- 회선 교환 방식 : 사용자 간 회선을 미리 선점한 후, 데이터를 송수신(ex. 전화)
- 패킷 교환 방식 : 데이터를 일정 크기로 분활하여 패킷으로 송수신(데이터그램 방식과 가상 회선 방식)
##### 3.1.3.5 패킷 교환 기술
- 생략
#### 3.1.4 TCP/IP 및 네트워크 프로토콜의 이해
##### 3.1.4.1 프로토콜
- 통신을 위한 규약. 형식, 의미, 타이밍 정의 필요
- 프로토콜 제정 위원회
  - 국제표준기구(ISO) : OSI 계층 만듬
  - 미국국립표준협회(ANSI) : 사립 비영리 법인
  - 국제전기통신연합(ITU-T) : 일반 전기, 전화 통신 시스템 표준
  - 전기전자공학회(IEEE) : 전자전기 및 컴퓨터 통신 표준 개발(세계에서 가장 큼)
  - 전자산업협회(EIA) : 물리적 연결 인터페이스와 전자신호 규격 규정
  - 한국정보통신기술협회(TTA)
##### 3.1.4.2 TCP/IP
- 통신 계층까지의 데이터 통신의 신뢰성을 보장하는 프로토콜
- 통신 계층 핵심 개념
  - 포트 번호 : 0~65535 사이의 번호이고, 0~1023은 well-known임
  - 소켓 : 상대방 프로그램과 통신하기 위해 소켓을 생성하여 연결함
##### 3.1.4.3 IP 주소
- 네트워크 계층에서의 호스트 고유 주소
- IP 주소 클래스
  - A 클래스 : 첫번째 옥텟이 0 이므로 1~126.0.0.0 사용 가능. 127은 예약된 주소
  - B 클래스 : 첫번째 옥텟이 10 이므로 128~192.255.0.0 사용 가능
  - C 클래스 : 첫번째 옥텟이 110 이므로 193~223.255.255.0을 주소로 활용 가능
  - D 클래스 : 옥텟이 1110 이므로 224~239.0.0.0 주소로 활용 가능하나 다중 방송 통신용으로 예약됨
  - E 클래스 : 옥텟이 1111 이므로 240~255.0.0.0 주소로 활용 가능하나 연구용으로 예약됨
##### 3.1.4.4 서브넷
- 호스트 주소 중 일부를 서브넷 네트워크 주소로 활용하여 네트워크를 분할하는 기법
- 서브넷을 구성하여 브로드캐스트 크기를 작게해 라우팅 정보 크기를 감소시킬 수 있음
- ex. C 클래스 서브넷 마스크 적용하기
- ex. 200.168.123.0 주소를 할당받았다고 가정. 만약 서브넷이 없다면 2^8 = 256개 호스트 주소 생성 가능
- 11111111.11111111.11111111.xx000000을 서브넷 마스크로 하여 4개의 서브넷을 생성한다고 가정
  - 11111111.11111111.11111111.11000000 : 200.168.123.0~63. 즉 총 64개 호스트 주소 생성
  - 11111111.11111111.11111111.10000000 : 200.168.123.64~127
  - 11111111.11111111.11111111.01000000 : 200.168.123.128~191
  - 11111111.11111111.11111111.00000000 : 200.168.123.192~255
##### 3.1.4.5 도메인
- ex. www.google.com
  - 최상위 도메인 : .com
  - 도메인 이름 : google
  - 서브 도메인 : www
- DNS : 도메인 이름으로 ip를 찾을 수 있는 시스템
##### 3.1.4.6 IPv6
- 총 128비트로 16비트 단위로 8자리로 구성

### 3.2 네트워크 설정
#### 3.2.1 환경설정
##### 3.2.1.1 리눅스 네트워크 환경설정 개요
##### 3.2.1.2 이더넷 카드 설치 
- 적절한 드라이버 설치
##### 3.2.1.3 인터넷 접속을 위한 네트워크 인터페이스 설정
#### 3.2.2 네트워크 설정 명령어
##### 3.2.2.1 ifconfig
- 네트워크 인터페이스 환경설정 수행하는 명령어 역할
- ```ifconfig [네트워크 인터페이스명]```으로 해당 네트워크 인터페이스 설정만 확인 가능
##### 3.2.2.2 nmcli
- NetworkManager Command Line Interface
##### 3.2.2.3 route
- 라우팅 테이블 표시 및 수정
##### 3.2.2.4 arp
- arp 캐시 등의 정보가 포함됨
#### 3.2.3 네트워크 진단 명령어
##### 3.2.3.1 ethtool
- ethtool : 네트워크 인터페이스 카드 유틸리티 및 설정 도구
##### 3.2.3.2 ip
- ifconfig 대체 명령어
##### 3.2.3.3 ping
- 원격 호스트가 네트워크 연결 상태인지 확인하는 상태 진단 명령어
##### 3.2.3.4 netstat
- 네트워크 관련 정보 출력하는 명령어
  - LISTEN : 소켓이 클라이언트 연결을 기다리는 중
  - SYN_RCVD : 서버가 클라이언트의 SYNC를 받고 연결 대기 중
  - ESTABLISHED : 클라이언트와의 연결이 완료됨
  - FIN_WAIT1 : 연결 종료 FIN을 보내고 ack 응답 대기 중
  - CLOSE_WAIT1 : 연결 종료 FIN을 받고 ack를 보낸 상태
##### 3.2.3.5 traceroute
- 패킷이 어느 경로로 전송되었는지 추적하기 위한 명령어
##### 3.2.3.6 mii-tool
- 네트워크 인터페이스 연결상태 확인
##### 3.2.3.7 ss
- 소켓 연결상태 확인
#### 3.2.4 DNS 명령어
##### 3.2.4.1 nslookup
- ip를 통해 도메인 이름을 찾을 수 있는 명령어





























































































































