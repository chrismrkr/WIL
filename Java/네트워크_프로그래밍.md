# 네트워크 프로그래밍

## 1. 연결 및 메세지 송수신

네트워크 프로그래미에서는 소켓을 통해서서로 데이터를 송수신할 수 있다. 전송 계층에서 TCP 연결이 완료되면, 어플리케이션 단에서는 소켓을 통해서 데이터를 수신하고 상대방에게 다시 전달할 수 있다.

예시는 아래와 같다.

```java
void startClient() throws IOException {
  Socket socket = new Socket("localhost", 8080")
  DataInputStream input = new DataInputStream(socket.getInputStream());
  DataOutputStream output = new DataOutputStream(socket.getOutputStream());

  output.writeUTF("hello world");
  String recv = input.readUTF();
  log("recv: " + recv);

  input.close();
  output.close();
  socket.close();
}

void startServer() throws IOException {
  ServerSocket server = new ServerSocket("localhost", 8080);
  
  Socket connection = server.accept();
  DataInputStream input = new DataInputStream(connection.getInputStream());
  DataOutputStream output = new DataOutputStream

  String recv = input.readUTF();

  String send = "Hello! " + recv;
  output.writeUTF(send);

  input.close();
  output.close();
  socket.close();
}
```

TCP 연결이 완료되면 Server 단의 OS Backlog Queue에 연결정보가 쌓인다. 그리고, ```accept()``` 메소드를 통해 Socket이 생성되는 시점에 OS Backlog Queue에 쌓인 정보를 삭제한다.

TCP 연결이 완료되었으므로 클라이언트 단에서 서버 단으로 메세지 전송이 가능하다. 하지만, 어플리케이션 단에서는 Socket이 생성되어야만 이를 읽을 수 있다.

## 2. 자원 정리

Socket, InputStream, OutputStream 모두 파일 디스크립터와 같은 OS 리소스를 사용하므로 GC 대상이 되지 않는다. 그러므로, 개발자가 직접 자원 정리를 해야 한다.

### 2.1 finally를 활용한 자원 정리

try-catch-finally 구문을 통해서 아래와 같이 자원을 정리할 수 있다.

```java
try {
  // Do Something
} catch(IOException e) {

} finally {
  input.close();
  output.close();
  socket.close();
}
```

### 2.2 try-with-resources 활용한 자원 정리

아래와 같이 자원을 정리할 수 있다. finally이 에서 따로 자원을 정리하지 않아도 할당한 객체가 ```AutoCloseable```을 구현한 객체라면 자동으로 try 블록을 벗어날 때 자원이 정리된다.

```java
try (
  Socket socket = new Socket("localhost", 8080);
  InputStream input = socket.getInputStream();
  OutputStream output = socket.getOutputStream();
) {

} catch(Exception e) {
  // ...
}
```

### 2.3 Shutdown Hook을 활용한 자원 정리

클라이언트가 종료될 때는 2.1, 2.2에서 제공한 방식으로 처리를 할 수 있다.

하지만, 서버 컨테이너가 강제 종료될 때도 기존에 할당되어 있는 자원을 해제할 필요가 있다. 방법은 아래와 같다. 

```java
Runtime.getRuntime().addShutdownHook(new Thread(...));
```

서버 컨테이너가 Shutdown 될 때 ```addShutdownHook``` 메소드에 인자로 넘겼던 스레드가 실행된다. 해당 스레드에 자원을 전체적으로 정리하는 소스를 실행하도록 하면 된다.

예를 들면, SessionManager 객체에 현재 연결된 Socket 객체를 모두 저장을 하고, 여기서 Socket이 관리되는 형태로 코드를 작성한 후, Shutdown Hook이 실행될 때 SessionManager를 통해 자원이 정리되도록 하면 된다.


## 3. 네트워크 예외

### 3.1 연결 예외
- java.net.UnknownHostException : 연결하려고 했으나 적절한 Host를 찾지 못한 경우
- java.net.ConnectException: Connetion refused : 연결을 시도했으나 TCP 연결 자체에 실패하여 RST(Reset) 패킷을 받은 경우

### 3.2 타임아웃 예외

#### 3.2.1 java.net.ConnectException: Operation timed out (연결 타임아웃)

연결을 시도했으나 timeout이 발생한 에러이다. TCP 연결을 클라이언트가 무한정 기다리는 것도 좋은 방법이 아니므로 직접 타임아웃을 설정하는 것도 좋다.

#### 3.2.2 java.net.SocketTimeoutException : Read Time out (소켓 타임아웃)

클라이언트가 서버 단과 연결된 이후, 서버에 요청을 보냈으나 이에 대한 응답이 오지 않을 수 있다. 이러한 경우에 일정시간 이후에 발생하는 예외가 SocketTimeout : Read Time out 이다

### 3.3 종료 예외

#### 3.3.1 정상적으로 종료된 상황

클라이언트나 서버 단에서 ```socket.close()```를 통해서 연결이 종료될 수 있다. 클라이언트와 서버는 각각 2-way, 총 4-way로 연결을 종료하게 된다. 이것이 정상적으로 종료되는 상황이다.

정상적으로 연결이 종료된 이후, 데이터를 읽으면 null, -1, EOFException 등을 반환한다.

#### 3.3.2 강제 종료되는 상황

TCP 연결 중 문제가 발생하면 RST 패킷을 전송한다. RST 패킷이 도착했다는 것은 현재 연결에 심각한 문제가 있으므로 해당 Connection을 사용해서는 안된다는 것을 의미한다.

RST 패킷을 수신하게 되면 연결을 즉시 해제해야 한다. 즉, RST 패킷을 받는 경우에는 현재 Socket과 관련되어 있는 모든 리소스를 해제해야함을 의미한다.

RST 패킷을 수신한 후 Socket에 read, write를 했을 때 발생하는 Exception은 아래와 같다.

+ java.net.SocketException: Connection reset : RST 패킷 수신 후 Read 했을 때 발생함
+ java.net.SocketException: Broken Pipe : RST 패킷 수신 후 Write 했을 때 발생함
+ java.net.SocketException: Socket is close : 본인이 Socket을 Close한 이후 read, write를 했을 때 발생함

EOFException, SocketException 모두 IOException의 자식이다. 그러므로, IOException이 Catch되면 리소스를 정리하도록 구현해야 한다.

