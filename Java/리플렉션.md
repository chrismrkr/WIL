# 리플렉션

클래스가 제공하는 다양한 정보를 런타임에 가져올 수 있는 기능을 reflection이라고 한다.

## 1. 클래스와 메타데이터

리플렉션을 통해 얻을수 있는 정보는 아래와 같다.

+ 클래스의 메타정보
+ 필드 정보
+ 메서드 정보
+ 생성자 정보

리플렉션을 통해서 클래스 정보를 런타임에 가져오는 예시는 아래와 같다.

```java
public class ReflectionExercise {
  public void main(String[] args) throws IOException {
    // 1. 클래스로 찾기
    Class<BasicClass> basicClass1 = BasicClass.class;
    // 2. 인스턴스에서 찾기
    BasicClass basicInstance = new BasicClass;
    Class<? extends BasicClass> basicClass2 = basicInstance.getClass();
    // 3. 문자로 찾기
    String className = "com.BasicClass";
    Class<?> basicClass3 = Class.forName(className);
  }
}
```

```Class```를 통해서 클래스 이름, 패키지명, 부모 클래스 등의 클래스 메타 정보를 동적으로 런타임에 획득할 수 있다.

## 2. 메소드 탐색과 동적 호출

리플렉션으로 메소드를 동적으로 획득하는 방법은 아래와 같다.

```java
public class ReflectionExercise {

  public void main(String[] args) throws IOException {
    Class<BasicClass> basicClass = BasicClass.class;

    // 상위 클래스를 포함한 모든 public 메소드 탐색
    Method[] methods1 = basicClass.getMethods();

    // 상위 클래스를 제외한 현재 클래스의 모든 메소드 탐색(접근 제어자 관계 없이 반환)
    Method[] methods2 = basicClass.getDeclaredMethods();

    // 특정 메소드 반환 : String 2개를 인자로 갖는 helloMethod(String, String) 메소드 호출
    Method method3 = basicClass.getMethod("helloMethod", String.class, String.class);

    // 메소드 호출
    methods3.invoke(param1, param2); 
  }
}
```

## 3. 필드 탐색과 값 변경

메소드 탐색 및 호출과 유사한 방법으로 동적으로 필드를 탐색하고 값을 변경할 수 있다.

private 접근 제어자도 직접 접근해서 변경이 가능하므로 가급적이면 테스트 및 라이브러리 개발 등에만 사용하면 좋다.

## 4. 생성자 탐색 및 객체 생성

메소드 탐색 및 동적 호출과 유사한 방식으로 생성자를 얻고 객체를 생성할 수 있다.

## 5. Example. 서블릿 구현

리플렉션을 사용하지 않고, /hello 요청은 "hello"를 반환하고, /bye 요청은 "bye"를 반환하는 서블릿은 아래와 같이 만들 수 있다.

```java

public class DispatcherServlet implements Servlet {
    Map<String, Servlet> servletMap = new HashMap<>();
    @Override
    public void dispatch(HttpServletRequest req, HttpServletResponse res) {
      servletMap.get(req.getUri()).dispatch(req, res);
    }
}
```

/hello, /bye 요청에 대한 Servlet이 개별적으로 존재해야 한다. 그러므로, uri 마다 개별적인 서블릿 구현체가 필요하다는 단점이 있다.

이것을 해결하기 위해서 /hello인 경우에는 hello() 메소드를 호출하고, /bye인 경우에는 bye() 메소드를 호출하도록 하면 된다. 이때 리플렉션을 활용할 수 있다.

```java
public class ReflectionDispatcherSerlvet implements Servlet {

}
```


