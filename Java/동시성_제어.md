# 동시성 제어

멀티 스레드 상황에서의 동시성 제어 방법에 대해서 정리한다.

### 1. volatile

아래와 같은 코드가 있다.

```java
public class MyRunnable implements Runnable {
  boolean flag = true;
  public void run() {
    while(flag) {
      System.out.println("DO Something");
    }
  }
}

public static void main(String[] args) throws IOException {
  Runnable task = new MyRunnable();
  Thread thread = new Thread(task);
  task.flag = false;
} 
```

위처럼 main()에서 ```flag```를 false로 변경한다면 중단이 될까? 그렇지 않다.

이유는 스레드가 힙 메모리 영역의 객체를 참조할 때 메인 메모리에 있는 것에 직접 접근하는 것이 아니라 캐시 메모리에 있는 것에 접근하기 때문이다.

그러므로, ```task.flag = false```를 통해 메인 메모리에 있는 값을 변경하더라도 캐시 메모리에 있는 것은 변경되지 않았으므로 코드는 중단되지 않는다.

이때 캐시 메모리가 아닌 항상 메인 메모리를 통해서 직접 접근할 수 있도록 만드는 것이 ```volatile``` 이다.

```volatile boolean flag```와 같이 필드를 선언함으로써 항상 메인 메모리에 있는 필드에 접근하게 하여 위 문제를 해결할 수 있다.

즉, 멀티 스레드 환경에서 공유 자원을 READ 하는 상황에서는 ```volatile```로 동시성 문제를 해결할 수 있다. 그러나, 여러 스레드가 동시에 WRITE 하는 상황에서는 ```volatile``` 만으로는 해결할 수 없다.

### 2. 메모리 가시성

한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지 대한 것을 메모리 가시성(Memory Visibility)라고 한다.

멀티 스레드 프로그래밍 시 happens-before, 이전에 일어난 작업의 모든 변경 사항은 그 다음에서 볼 수 있어야 한다는 원칙에 따를 때 예상치 못한 동작을 피할 수 있다.


### 3. synchronized - 동기화 락

synchronized를 통해서 모니터 락을 획득하여 공유 자원에 대한 동시 처리를 할 수 있다.



