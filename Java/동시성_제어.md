# 동시성 제어

멀티 스레드 상황에서의 동시성 제어 방법에 대해서 정리한다.

### 1. volatile

아래와 같은 코드가 있다.

```java
public class MyRunnable implements Runnable {
  boolean flag = true;
  public void run() {
    while(flag) {
      System.out.println("DO Something");
    }
  }
}

public static void main(String[] args) throws IOException {
  Runnable task = new MyRunnable();
  Thread thread = new Thread(task);
  task.flag = false;
} 
```

위처럼 main()에서 ```flag```를 false로 변경한다면 중단이 될까? 그렇지 않다.

이유는 스레드가 힙 메모리 영역의 객체를 참조할 때 메인 메모리에 있는 것에 직접 접근하는 것이 아니라 캐시 메모리에 있는 것에 접근하기 때문이다.

그러므로, ```task.flag = false```를 통해 메인 메모리에 있는 값을 변경하더라도 캐시 메모리에 있는 것은 변경되지 않았으므로 코드는 중단되지 않는다.

이때 캐시 메모리가 아닌 항상 메인 메모리를 통해서 직접 접근할 수 있도록 만드는 것이 ```volatile``` 이다.

```volatile boolean flag```와 같이 필드를 선언함으로써 항상 메인 메모리에 있는 필드에 접근하게 하여 위 문제를 해결할 수 있다.

즉, 멀티 스레드 환경에서 공유 자원을 READ 하는 상황에서는 ```volatile```로 동시성 문제를 해결할 수 있다. 그러나, 여러 스레드가 동시에 WRITE 하는 상황에서는 ```volatile``` 만으로는 해결할 수 없다.

#### volatile이 이용되는 사례

### 2. 메모리 가시성

한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지 대한 것을 메모리 가시성(Memory Visibility)라고 한다.

멀티 스레드 프로그래밍 시 happens-before, 이전에 일어난 작업의 모든 변경 사항은 그 다음에서 볼 수 있어야 한다는 원칙에 따를 때 예상치 못한 동작을 피할 수 있다.


### 3. synchronized - 동기화 락

synchronized를 통해서 공유 자원에 대한 모니터 락을 획득할 수 있다.

모니터 락을 통해서 임계 영역이 설정되고, 특정 스레드가 임계 영역에서 작업 중이라면 다른 스레드가 동시에 임계 영역에 접근할 수 없고 Thread BLOCKED 상태가 된다.

동기화 락을 획득하는 방법은 아래와 같다.

```java
public class MyClass {
  private int count = 0;
  public synchronized void mySynchronizedTask1() {
    this.count += 1;
  }

  public void mySynchronizedTask2() {
    synchronized (this) {
      this.count += 1;
    }
  }
}
```

synchronized는 간편하게 공유자원에 대한 잠금 및 해제를 할 수 있다.

그러나, BLOCKED된 스레드는 이전에 실행된 작업이 종료될 때 까지 무한 대기해야 하고, 스레드가 기다린 순서대로 락을 획득할 수 없기 때문에 공정성이 떨어진다.

### 4. Reentrant Lock

Lock 인터페이스는 아래와 같으며 ReentrantLock은 Lock 인터페이스의 구현체이다.

이를 활용해서 동기화 락(synchronized)의 무한 대기 및 공정성 문제를 해결할 수 있다.

```java
public interface Lock {
  void lock(); // 락을 획득한다. 이미 다른 스레드가 락을 획득한 상태라면 무한정 WAITING 상태가 되고 interrupt로도 WAITING이 풀리지 않는다.
  void lockInterruptibly(); // 락을 획득한다. 이미 다른 스레드가 락을 획득한 상태라면 무한정 WAITING 상태가 되나 interrupt 시 WAITING이 해제된다.
  boolean tryLock(); // 락을 획득하고 true를 반환한다. 이미 다른 스레드가 락을 획득한 상태라면 false를 반환한다.
  boolean tryLock(long time, TimeUnit unit); // tryLock()과 유사하나 일정 시간 동안 WAITING 상태로 대기한다는 점에서 다르다. interrupt를 통해 InterruptedException을 일으킬 수 있다.
  Condition newCondition(); // 추후 설명
}
```




