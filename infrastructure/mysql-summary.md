# MySQL
Real MySQL 8.0 서적 및 MySQL Document를 참고하여 요약함

## 1. 설정

### 1.1 서버 시작 및 종료
- 일반적으로 /etc/my.cnf 환경설정 파일을 읽은 후,
- /usr/lib/systemd/mysqld.service 파일을 통해 MySQL 서버를 실행함
```shell
systemctl start mysqld
```

### 1.2 서버 연결
+ mysql.sock을 이용한 연결
+ tcp/ip를 이용한 연결
+ mysql -uroot -p 명령어를 통한 연결

### 1.3 서버 설정
- my.cnf : MySQL 시스템 변수 저장
  - mysql --help로 서버 시작 시 my.cnf 파일을 읽는 우선순위 확인 가능
- 시스템 변수 : DB 설정과 관련된 변수
  - ```SHOW VARIABLES;``` 명령어로 확인 가능
  - MySQL 메뉴얼에서 자세한 시스템 변수 확인할 것
 
### 1.4 글로벌 변수와 세션 변수
- 글로벌 변수 : 서버 인스턴스 전체에 영향을 미치는 변수(ex. InnoDB 스토리지 엔진 버퍼 크기)
- 세션 변수 : 현재 서버에 연결한 클라이언트 세션에 부여되는 변수(ex. autocommit)
- Both : 서버가 기억을 하고 있다가 클라이언트와의 커넥션 생성 시 시스템 변수를 해당 변수로 변경하기 위해 사용하는 변수

### 1.5 정적 변수와 동적 변수
- 정적 변수 : 서버 기동 중인 상태에서 변경할 수 없는 변수(시스템변수 설정 파일 값)
- 동적 변수 : 서버 기동 중인 상태에서 변경할 수 있는 변수(메모리 적재된 변수)
- SET, GLOBAL, PERSIST 명령어를 적절히 사용하여 동적 및 정적 변수 변경 가능

### 1.6 SET PERSIST
- MySQL 8.0 버전 이상에서 지원
- ```SET PERSIST [글로벌 변수=ㅁㅁ];``` 커맨드 시, 현재 메모리에 적재된 변수를 변경하고 mysqld-auto.cnf에 저장함
- 그리고 MySQL 서버 재시작 시, my.cnf와 mysqld-auto.cnf를 스캔하여 이를 글로벌 변수로 설정함
- 세션 변수에는 ```SET PERSIST```를 적용할 수 없음
- ```SET PERSIST_ONLY [글로벌 변수=ㅁㅁㅁ];``` 명령으로 mysqld-auto.cnf에만 저장할 수 있음
  - 현재 메모리에 적재된 글로벌 변수를 변경할 수 없을 때 사용함
    
***

## 2. 사용자 및 권한

### 2.1 사용자 식별
- MySQL은 호스트명과 ip 모두 계정의 일부임
  - ex1. 'mysql'@'127.0.0.1' : 로컬 호스트에서만 접근 가능한 계정인 mysql
  - ex2. 'mysql'@'%' : 모든 호스트에서 접근 가능한 계정인 mysql

### 2.2 사용자 계정 관리
- 시스템 계정과 일반 계정
  - 시스템 계정 : SYSTEM_USER 권한이 있는 계정(관리자 계정)
  - 일반 계정 : 응용프로그램 및 개발자를 위한 계정
- 계정 생성
  - ```CREATE USER '[사용자명]'@'[허용 호스트 IP]' IDENTIFIED WITH '[패스워드]';```
  - 계정 생성 관련 옵션
    - REQUIRE : SSL/TLS 채널 사용여부
    - PASSWORD EXPIRE : 유효기간 설정. 미설정 시 default_password_lifetime 시스템 변수를 따름
    - PASSWORD HISTORY : 한번 사용했던 패스워드는 재사용할 수 없도록 만드는 것과 관련된 옵션
    - PASSWORD REUSE INTERVAL : 한번 사용했던 패스워드 재사용 금지 기간 설정. 미설정 시 password_reuse_interval 시스템 변수를 따름
    - PASSWORD REQUIRE : 패스워드 만료로 인하여 재설정 시 현재 패스워드를 필요로 할지 말지 결정하는 옵션. 미설정 시 password_require_current 시스템 변수를 따름

### 2.3 비밀번호 관리 
- 고수준 비밀번호 : componet_validate_password를 설치하여 패스워드 유효성 관리 가능
- 이중 패스워드 : 햔재 패스워드, 이전 패스워드 중 하나만 일치해도 인증에 성공하는 방식
  - ```ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password' RETAIN CURRENT PASSWORD;```
    - 새로운 패스워드를 설정하고 현재 패스워드는 이전 패스워드로 설정함
  - ```ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password' DISCARD OLD PASSWORD;```
    - 패스워드를 변경하고 현재 패스워드는 삭제함

### 2.4 권한
- ```GRANT``` 커맨드로 권한 부여
- 객체 권한 : 데이터베이스나 테이블을 제어하기 위한 권한(DB, TABLE 지정 필요)
- 글로벌(정적) 권한 : 데이터베이스, 테이블 이외의 객체를 제어하기 위한 권한
- 동적 권한 : MySQL 서버가 시작하면서 동적으로 생성되는 권한
- 권한 부여 방법
  - 객체 권한 : ```GRANT [권한 목록(SELECT, UPDATE, ...)] ON [db].[table] TO '[사용자명]'@'[허용 호스트 ip]';```
  - 정적 권한 : ```GRANT [정적 권한 목록] ON *.* TO '[사용자명]'.'[허용 호스트 ip]';```
  - DB 권한 : ```GRANT [권한 목록] ON [db].* TO '[사용자명]'.'[허용 호스트 ip]';```

### 2.5 역할
- 여러개의 권한이 부여된 접속 불가능한 계정을 만드는 것. 이를 역할이라 함
- 역할과 계정은 MySQL 내부적으로 동일함
- 역할 생성 과정
  - ```CREATE ROLE [역할 이름];```
  - ```GRANT [권한 목록] ON [db].[table] TO [역할 이름];```
  - ```CREATE USER '[사용자명]'@'[허용 호스트 ip]' IDENTIFIED BY '[password]';```
  - ```GRANT [역할 이름 목록] TO '[사용자명]'@'[허용 호스트 ip]';```
- 주의 사항
  - 사용자 로그인 시, 역할이 자동으로 부여되지 않음
  - activate_all_roles_on_login=ON 시스템 변수를 통해 로그인시 자동으로 역할이 부여되도록 함

***

## 3. 아키텍처
MySQL은 MySQL 엔진과 스토리지 엔진으로 구성되고, 스토리지는 InnoDB를 기본으로 채택함

### 3.1 MySQL 엔진
DB 커넥션 핸들링, SQL 파싱, 쿼리 최적화를 담당함
#### 3.1.1 스레딩 구조
- performance_schema.thread 테이블에서 현재 실행 중인 스레드 확인 가능
  - FOREGROUND thread : 클라이언트가 요청하는 쿼리를 처리함
    - 동작 메커니즘 : 스레드 처리 -> 커넥션 종료 -> 스레드 캐시 반납
      - 만약 thread_cache_size 시스템 변수 만큼의 스레드 캐시가 존재하면, 커넥션 종료 후 반납하지 않고 스레드를 종료함
    - 스레드 캐시란? : 유휴 포어 그라운드 스레드를 갖고 있는 캐시
  - BACKGROUND thread : InnoDB 스토리지 엔진에 특정 작업을 처리함
    - 로그 쓰기 스레드
    - InnoDB 버퍼 데이터 풀 -> 디스크 쓰기 스레드
#### 3.1.2 메모리 할당 방식
- 글로벌 메모리 영역
  - 시스템 변수에 설정한 만큼 운영체제에서 할당함
  - 모든 MySQL 스레드끼리 공유함
  - 테이블 캐시, InnoDB 버퍼 풀, InnoDB 해시 인덱스, InnoDB 리두 로그 버퍼 등에 해당됨
- 로컬(세션) 메모리 영역
  - MySQL 클라이언트 - 서버 연결 시 생성되는 스레드가 사용하는 메모리
  - 커넥션을 연결하는 동안 계속 유지함(커넥션 버퍼, 아웃풋 버퍼 메모리)
  - 쿼리를 수행할 때 할당 및 해제함(소트 버퍼, 조인 버퍼 메모리)
#### 3.1.3 플러그인 스토리지 엔진 모델
- 스토리지 엔진, 검색어 파서, 사용자 인증 플러그인 등이 존재함
- ```SHOW ENGINES;```로 지원하는 스토리지 엔진 확인 가능
- ```SHOW PLUGINS;```로 지원하는 플러그인 확인 가능
#### 3.1.4 쿼리 실행 과정
- 쿼리 파싱 -> 전처리 -> 옵티마이저 -> 실행 엔진 -> 핸들러
#### 3.1.5 쿼리 캐시
- MySQL 8.0 이상에서는 삭제됨
- 동일한 쿼리의 결과를 캐시함. 그러나, 데이터 변경으로 인한 캐시 Flush 시 삭제됨
#### 3.1.6 스레드 풀
- MySQL 엔터프라이즈 버전에서만 사용 가능하나 Percona Server에서 스레드 풀 플러그인 라이브러리를 설치해서 사용 가능
- thread_pool_size 시스템 변수로 설정 가능(일반적으로 코어 수와 동일하게 함)
- thread_pool_stall_limit 시스템 변수로 스레드 풀 full 상태를 밀리 초 단위로 체크
- thread_pool_max_threads에 따라 스레드 풀 full 시 추가 스레드 생성 여부 결정
#### 3.1.7 메타 데이터
- 테이블 메타 데이터는 InnoDB 테이블에 저장됨

### 3.2 InnoDB 스토리지 엔진
#### 3.2.1 기본 키에 의한 클러스터링
- InnoDB 모든 테이블은 기본 키가 클러스터링 인덱스이므로 기본 키를 통한 Range Search 성능이 높음
- 반면 MyISAM은 클러스터링 인덱스가 없음
#### 3.2.2 외래키 지원
- 외래키를 생성하면 자동으로 외래 키에 대한 인덱스가 생성됨
- 테이블 변경 시 외래키에 의한 정합성 체크 과정이 자식 테이블로 계속 전파되고, 이에 따라 Lock이 발생하므로 데드락에 주의해야함
- foreign_key_checks=OFF 시스템 변수를 통해 일시적으로 외래키 관계 체크를 멈출 수 있음
#### 3.2.3 MVCC(Multi Version Concurrency Control) 지원
- Lock을 사용하지 않고도 일관된 읽기를 제공하기 위해 레코드 레벨의 트랜잭션을 지원함
- 테이블이 변경되는 프로세스(격리수준 : REPEATABLE READ)
  - DML(UPDATE, INSERT, DELETE) Query 발생
  - InnoDB 버퍼 풀 변경
  - Undo Log 기록
  - Commit -> 버퍼 풀 내용을 디스크에 기록 & Undo Log 삭제
- 위 상황에서 Commit 되지 않은 상태에서 다른 트랜잭션이 해당 데이터를 Read 하려고 하면 Undo Log에 있는 값을 읽게 함
- 이를 통해 Lock 없이 MVCC를 제공함
- 만약 Undo Log가 지워지지 않고 계속 남아있으면 DB 성능에 악영향을 줌
#### 3.2.4 자동 데드락 감지 지원
- 잠금 대기 목록(Wait-for List) 그래프를 통해 데드락을 모니터링함
- 만약 데드락이 감지되는 경우, 언두 로그가 적은 쪽을 롤백함
- MySQL 엔진은 레코드 락을 감지할 수 있으나 테이블 락(IX, IS)은 감지할 수 없음
- innodb_table_locks 시스템 변수를 활성화하여 테이블 락 상태를 확인할 수 있음
- 동시 처리 스레드가 많아지는 상황에서는 데드락 감지 스레드가 느려짐
  - 잠금 대기 목록에 잠금을 걸고, 그 위에 또 잠금을 거는 것이 반복되는 상황
  - innodb_deadlock_detect=OFF 및 innodb_lock_wait_timeout 시스템 변수를 설정하여 대응할 수 있음
#### 3.2.5 자동화된 장애 복구 지원
- 데이터 파일은 일반적으로 깨지지 않으므로 MySQL 시작 시 완료되지 않은 작업을 자동으로 반영함
- 그러나, InnoDB 스토리지 엔진이 자동 복구를 하지 못하는 경우, innodb_force_recovery 시스템 변수를 사용해야함
#### 3.2.6 InnoDB 버퍼 풀
- DML에 의해 발생하는 디스크 I/O 작업 횟수를 줄일 수 있음
- 버퍼 풀 크기 설정
  - 서버 전체 물리 메모리의 약 50% 정도로 설정하고, 상황을 모니터링 하며 늘리는 것이 좋음
  - innodb_buffer_pool_size 시스템 변수로 버퍼 풀 메모리 전체 크기 설정 가능
  - innodb_buffer_pool_instances 시스템 변수로 버퍼 풀 인스턴스 개수 설정 가능
- 버퍼 풀 구조
  - Free : 아직 사용되지 않은 버퍼 풀 Page
  - LRU 리스트 : 디스크 읽기(OUT)가 있는 페이지를 저장하고, 자주 읽힐수록 앞쪽에 위치하고 일정 수준 뒤로 물러나면 제거됨
  - Flush 리스트 : 더티 페이지(디스크 IN)를 관리하고 특정 시점에 더티 페이지를 디스크에 반영함
    - 더티 페이지 발생 시, 이를 Redo Log에 반영함(항상 동기화되지 않고 스토리지 엔진 체크포인트에 동기화됨)
- 버퍼 풀의 장점
  - 캐시 기능 : 버퍼 풀을 통해 캐시를 지원하므로 읽기 성능을 높임(디스크 OUT)
  - 쓰기 버퍼링 : 체크 포인트의 LSN보다 작은 Redo Log와 관련된 더티 페이지를 디스크에 동기화함
    - Redo Log는 데이터의 변경 분만 갖고 있으므로 버퍼 풀과 크기가 동일해야 하는 것은 아님
- 버퍼 풀 플러시
  - 버퍼 풀을 디스크에 동기화하는 것을 의미하고 아래 2가지가 백그라운드 스레드에서 실행됨
  - Flush 리스트 플러시
    - 오래된 리두 공간을 지우고 더티 페이지를 디스크에 동기화함
  - LRU 리스트 플러시
    - 최근에 사용되지 않은 버퍼 풀을 제거함. 캐시가 꽉 찼을 때 발생함
- 버퍼 풀 관련 InnoDB 시스템 변수 설정
  - innodb_page_cleaners : Flush 리스트 플러시를 수행하는 스레드 수. 일반적으로 innodb_buffer_pool_instances와 동일하게 함
  - innodb_max_dirty_pages_pct : 더티 페이지 차지 공간/버퍼 풀 전체 메모리 비율(기본 값 0.9)
  - innodb_io_capacity : 일반적인 상황에서의 초당 디스크 I/O 작업 수(더티 페이지 동기화와 관련 있으나 Disk Read도 고려해야 함)
  - innodb_io_capacity_max : 최대로 더티 페이지를 디스크에 쓸 수 있는 양
    - innodb_io_capacity와 max는 디스크 장비가 처리할 수 있는 수준으로 설정할 것
  - innodb_max_dirt_pages_pct_lwm : 일정 수준 이상의 더티 페이지가 쌓이면 조금씩 더티 페이지를 디스크에 기록함(기본 값 0.1)
  - innodb_adaptive_flushing : innodb_io_capacity, max를 따르지 않고 Redo Log 생성 속도에 따라 디스크 I/O 수를 결정하는 새로운 알고리즘에 따르는 설정
- 버퍼 풀 상태 백업 및 복구
  - 버퍼 풀에 캐시되어 있으면 시작 직후 보다 성능이 좋음(Warm Up 상태)
  - innodb_buffer_pool_dump_now=ON : 버퍼 풀 LRU 리스트 상태 백업
  - innodb_buffer_pool_load_now=ON : 백업된 것 복구
  - ```SHOW STATUS LIKE 'innodb_buffer_pool_dump_status';``` 명령어로 복구 진행 상황 확인 가능
  - ```SET GLOBAL innodb_buffer_pool_load_abort_ON;``` : 버퍼 풀 복구를 중지하고 즉시 실행
  - innodb_buffer_pool_dump_at_shutdown, innodb_buffer_pool_load_at_startup : 서버 시작 및 종료 시 자동으로 백업, 복구 되도록 설정
- 버퍼 풀 적재 내용 확인
  - information_schema.innodb_cached_indexes, innodb_tables, innodb_indexes 테이블을 적절히 조인하여 현재 차지하고 있는 버퍼 풀 데이터 페이지 수를 확인할 수 있음
#### 3.2.7 Double Write Buffer
- 더피 페이지 및 Redo 로그를 디스크에 동기화할 때, 하드웨어 오동작 등으로 비정상 종료될 수 있음
- 이를 방지하기 위해 Double Write Buffer에 더티 페이지를 먼저 저장함
- innodb_doublewrite로 제어 가능
#### 3.2.8 Undo Log
- 트랜잭션 격리 수준에 따라 DML 작업으로 데이터가 변경되기 전에 이전 버전을 백업하는 파일
- 레코드마다 존재함
#### 3.2.9 Redo Log 및 로그 버퍼
- Redo Log : 트랜잭션 Duration을 보장하기 위해 사용됨
  - Write Ahead Log(WAL) : 디스크에 쓰기 이전에 기록되는 로그라고 불림
  - MySQL 비정상 종료로 인하여 디스크에 제대로 반영되지 않아도 Redo 로그를 통해 복구 가능
  - innodb_flush_log_at_trx_commit 시스템 변수를 통해 Redo 로그 - 디스크 동기화 방식 설정 가능
  - SET GLOBAL innodb_redo_log_archive_dirs='디렉토리경로' 시스템 변수로 Redo 로그 아카이빙 지원
#### 3.2.10 어댑티브 해시 인덱스
- B-트리 기반 인덱스를 통한 검색 시간을 줄이기 위해 도입된 기능
- 자주 읽히는 데이터 페이지의 키 값을 이용하여 해시 인덱스를 생성하고 이를 저장함
- 어댑티브 해시 인덱스도 글로벌 메모리를 차지하므로 데이터 변경 시 해시 인덱스 변경을 위한 시스템 자원이 필요함
- 그러므로, 어댑티브 해시 인덱스 효과가 높지 않으면 사용하지 않아도 됨
- ```SHOW ENGINE INNODB STATUS;```로 조회 가능
  
### 3.3 MySQL 로그 파일
#### 3.3.1 에러 로그 파일
- log_error 시스템 변수에 에러 로그 파일을 저장할 경로를 설정함
- 기록되는 에러 로그 종류
  - MySQL 정상 기동 : mysqld: ready for connections
  - 시스템 환경변수 설정 오류 및 미인식
  - 비정상 종료로 인한 트랜잭션 복구 메세지
  - 쿼리 도중 발생한 에러
  - Aborted connection
  - InnoDB 모니터링, 상태 조회 명령, 종료 메세지
#### 3.3.2 제너럴 쿼리 로그 파일
- general_log_file 시스템 변수에 설정함
- MySQL이 쿼리 요청을 받으면 정상이든 아니든 모두 기록함
#### 3.3.3 슬로우 쿼리 로그
- long_query_time (초) 시스템 변수 이상 소요된 정상 쿼리를 시스템 변수 slow_query_log 경로의 파일에 저장함
- 슬로우 쿼리 관련 내용
  - Time : 쿼리가 끝난 시간
  - Query_time : 쿼리를 실행하는데 걸린 전체 시간
  - Lock_time : MySQL 엔진의 테이블 락을 위한 대기 시간
  - Rows examined : 쿼리 처리를 위해 몇건의 레코드에 접근했는지를 의미

***

## 4. 트랜잭션과 잠금
### 4.1 트랜잭션
- InnoDB는 Do or Nothing으로 동작함(Atomicity). 트랜잭션 내에서 하나라도 실패하면 모두 롤백함
- 그러므로, 트랜잭션 범위는 가능하면 최소화하는게 좋음
- ex. 게시물 저장 -> 첨부파일 저장 -> 게시물 및 첨부파일 내용 조회 -> 내용 알림 메세지 발송 -> 알림 메세지 이력 저장
  - 트랜잭션 1 : 게시물 저장 -> 첨부파일 저장
  - 트랜잭션 2 : 게시물 내용 조회 (조회는 트랜잭션을 걸지 않아도 됨)
  - 트랜잭션 3 : 알림 메세지 발송
  - 트랜잭션 4 : 알림 메세지 이력 저장

### 4.2 MySQL 엔진의 잠금
- MySQL은 MySQL 엔진 잠금과 스토리지 엔진 잠금 2가지를 지원함
- MySQL 엔진 락은 테이블 락, 메타 데이터 락, 네임드 락(특정 문자열에 거는 락)을 담당함
#### 4.2.1 글로벌 락
- 글로벌 락 : 가장 범위가 큰 락(```FLUSH TABLES WITH READ LOCK```)
  - 현재 세션을 제외한 다른 세션(연결)에서 DDL 또는 DML 불가능
  - mysqldump 시 글로벌 락이 발생하므로, MySQL 운영 서버는 소스 서버와 레플리카 서버 2대를 운영해야함
#### 4.2.2 테이블 락
- ```LOCK TABLES [table_name] [READ | WRITE];```
- ```UNLOCK TABLES [table_name];```
- 잘 사용되지는 않음
#### 4.2.3 네임드 락
- 사용자가 지정한 문자열에 락을 설정(이 문자열은 이 세션에서만 쓸 수 있다는 락)
#### 4.2.4 메타데이터 락
- 데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하고자 할 때 사용하는 락

### 4.3 InnoDB 스토리지 엔진 잠금
- InnoDB는 레코드 기반 락을 제공함
#### 4.3.1 InnoDB 스토리지 엔진 잠금 종류
- 레코드 락
  - 레코드의 인덱스를 잠금
  - 인덱스가 하나도 없는 테이블을 조회하더라도 InnoDB는 자동으로 기본 키 클러스터 인덱스를 생성하기 때문에 이를 통해 레코드 락을 설정함
- 갭 락
  - 레코드와 레코드 사이 간격에 새로운 레코드를 생성하지 못하도록 잠금함
  - InnoDB REPEATABLE READ 격리수준에서의 PHANTOM READ 문제 해결에 기여함
- 넥스트 키 락
  - 레코드 락과 갭 락을 합쳐놓은 상태(InnoDB에서 채택)
- 자동 증가 락
  - AUTO_INCREMENT
#### 4.3.2 인덱스와 잠금
- 조회 시 레코드 락이 발생하는데, 레코드 자체가 아닌 인덱스에 락을 검
- 예를 들어, ```UPDATE employees SET hire_date = now() WHERE first_name = 'gildong' and last_name = 'hong';```
- 인덱스가 first_name에만 있고 last_name에 없다면, first_name = 'gildong'과 관련된 인덱스를 모두 잠근 후 검색함
- 만약 인덱스가 전혀 없다면, 기본키 클러스터 인덱스에 락을 걸어 모든 레코드를 잠금 후 테이블을 full scan함
#### 4.3.3 레코드 수준의 잠금 확인 및 해제
- MySQL 5.1 이상 버전에서 레코드 잠금 및 잠금 대기 메타 데이터 조회가 가능함
- information_schema 데이터베이스의 INNODB_LOCKS, INNODB_TRX, INNODB_LOCK_WAITS 테이블을 조인하여 조회 가능
- MySQL 8.0 이상 : performance_schema 데이터베이스의 DATA_LOCKS, DATA_LOCK_WAITS 테이블에서 조회 가능

### 4.4 MySQL 격리 수준(Isolation Level)
- MySQL은 REPEATABLE READ, 오라클은 READ COMMITED를 주로 설정함
- READ UNCOMMITED
  - 커밋되지 않는 데이터도 조회할 수 있는 격리 수준
  - Dirty Read 문제가 발생할 수 있음
- READ COMMITED
  - 커밋된 데이터까지 조회하는 격리 수준
  - non-repeatable read 문제가 발생할 수 있음
- REPEATABLE READ
  - MVCC를 보장하기 위해 특정 트랜잭션 번호의 구간 내 백업된 Undo Log 보존 필요(start trx - end trx 사이에 쌓인 Undo 로그)
  - 순수 읽기는 Undo Log에 있는 레코드를 조회하므로 non-repeatable read 문제를 피할 수 있음
  - 다만 백업된 Undo Log가 많아질수록 MySQL 서버 처리 성능이 떨어질 수 있음
  - Phantom Read 문제가 발생할 수 있음
    - 왜냐하면 SELECT ~ FOR UPDATE 는 순수 읽기가 아닌 잠금 읽기 이므로 Undo Log가 아닌 테이블에서 읽으므로, 이러한 문제가 발생함
  - 그러나, MySQL은 갭 락(넥스트 키 락)을 사용하므로 REPEATABLE READ 격리 수준에서도 Phantom Read가 발생하지 않음
    - 왜냐하면 SELECT ~ FOR UPDATE가 일어나는 시점에 레코드 및 갭 락이 걸리므로, 다른 트랜잭션에서도 DML 작업을 할 수 없기 때문임
    - 하지만 아래의 경우에는 MySQL의 경우에도 Phantom Read가 발생하므로 주의가 필요함
      - T1: ---SELECT----------------------SELECT FOR UPDATE---------
      - T2: ------------INSERT-----COMMIT----------------------------
- Serializable
  - Write 뿐만 아니라 순수 Read에도 락을 걸음
  - 다만 동시 처리 능력이 떨어짐(데드락 가능성 증가)

***

## 5. 인덱스
### 5.1 인덱스 읽기 방식
- HDD & SSD
- 순차 I/O & 랜덤 I/O
### 5.2 인덱스란?
- DML(UPDATE, INSERT, DELETE) 성능을 희생하여 조회 성능을 높이는 방법
- 인덱스는 유니크 인덱스일 수 있고 아닐 수 있음
- 인덱스는 프라이머리 인덱스와 세컨더리 인덱스로 나뉨
### 5.3 B-Tree
#### 5.3.1 구조 및 특성
- 루트 노드, 브랜치 노드, 리프 노드로 구성된 Balanced Tree이고, 리프 노드는 디스크에 저장된 데이터 레코드를 찾아가기 위한 주소를 갖음
  - MyISAM의 리프 노드의 주소는 실제 데이터 레코드 주소임
  - InnoDB의 리프 노드의 주소는 프라이머리 키 인덱스 값임. 프라이머리 인덱스 키를 통해 디스크에 저장된 실제 데이터 레코드의 주소를 찾을 수 있음
#### 5.3.2 B-Tree 인덱스 키 Insert, Update, Delete
#### 5.3.3 B-Tree 인덱스 성능에 영향을 미치는 요소
- 인덱스 키 값의 크기
  - 버퍼 풀, 디스크, 인덱스 모두 페이지(블록) 단위로 저장 및 관리됨
  - 시스템 변수 innodb_page_size를 통해 페이지(블록) 사이즈를 설정함(기본 16KB)
  - 인덱스 키가 16바이트, 자식 노드 주소가 12바이트라면 페이지당 (16+12)/(1024*16)=585개를 갖음
  - 그러므로, 인덱스 키 값이 증가할수록 페이지에 담을 수 있는 개수가 감소함
- B-Tree 깊이
  - B-Tree 깊이가 깊어질수록 더 많은 페이지를 읽어야 함. 이에 따라 더 많은 디스크 읽기(I/O)가 발생함
- 선택도(기수성)
  - 인덱스 키 값이 100개이고, 인덱스의 유니크 키 값이 10개라면 선택도(기수성)은 100/10=10임
  - 선택도가 높을수록 중복된 키 값이 많다는 것을 의미하므로 검색대상이 줄어듬
  - 이에 따라, 검색 속도가 빨라짐
  - 그러므로, 선택도가 낮은 곳에 인덱스를 놓는 것이 효율적임
- 읽어야 하는 레코드 수
  - ex. 100만 건 데이터 중 50만 건을 읽는 방법
    - 1. 전체를 full scan 후 필요없는 50만 건을 버리기
    - 2. 인덱스로 필요한 50만 건 조회하기
  - 인덱스로 데이터를 읽는 것이 그렇지 않는 것 보다 비용이 4배 더 큼
  - 그러므로, 20~25%가 넘는 데이터 조회가 필요한 경우에는 테이블 full scan 후 필터링하는 것이 더 효과적
  - 조회조건에 의해 검색되는 레코드 개수에 따라 인덱스 설정 여부를 결정해야 함
#### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기 방식
- 인덱스 레인지 스캔
  - 검색해야할 인덱스 범위가 명확하게 결정되었을 때 사용하는 방식
    - ex. 인덱스가 (A) 에 설정되어 있고, WHERE A <= '...'로 조회
  - 인덱스는 정렬되어 있으므로 시작 위치를 찾은 후 종료 위치까지 순차적으로 읽으면 됨
- 인덱스 풀 스캔
  - 인덱스를 처음부터 끝까지 모두 읽는 방식
  - ex. 인덱스가 (A,B,C)에 설정되어 있고, WHERE B='...' AND C='...'로 조회
    - 이러한 경우에는 인덱스 (A,B,C)를 모두 스캔해야 함
- 루즈 인덱스 스캔
  - 모든 인덱스를 스캔하지 않음
  - ex. 인덱스가 (c1, c2)에 설정되어 있고, WHERE c1 in (...) GROUP BY c1으로 조회하는 경우
    - c1이 IN (...)에 해당되는 것만 조회한 후 이를 집계함. 이를 루즈 인덱스 스캔이라함
- 인덱스 스킵 스캔
  - MySQL 8.0 부터 지원함
  - 인덱스가 (c1, c2)에 설정되어 있고, WHERE c2='...'으로 조회
    - 1. c1의 유니크 값(c1_u1, c1_u2, ...)를 찾음
    - 2. 아래와 같이 내부적으로 여러번의 쿼리를 호출함
      - WHERE c1='c1_u1' AND c2='...'
      - WHERE c2='c1_u2' AND c2='...'
      - ...
  - EXPLAIN ([QUERY])로 실행 계획 확인 가능
  - 유니크 값이 많아질수록 오히려 성능이 떨어질 수 있음
#### 5.3.5 다중 칼럼 인덱스
- 2개 이상의 칼럼을 포함하고 있는 인덱스
#### 5.3.6 B-Tree 인덱스 정렬 및 스캔 방향
- 인덱스는 칼럼 별로 오름차순 또는 내림차순으로 정렬되어 있으나 옵티마이저의 실행 계획에 따라 이를 위에서 읽을지 아래로 읽을지 결정함
- 인덱스 정렬
  - 단일 또는 혼합 인덱스 생성 시, 아래의 방법으로 인덱스 설정 가능
    - ALTER TABLE t1 ADD INDEX ix_c1_c2 ON t1 (c1 ASC, c2 DESC);
- 인덱스 스캔 방향
  - 인덱스 칼럼이 오름차순 또는 내림차순으로 정렬되어 있어도 옵티마이저의 실행계획에 따라 정방향 또는 역방향 스캔을 결정함
  - 역방향 스캔이 정방향 스캔보다 느림
#### 5.3.7 B-Tree 인덱스의 가용성과 효율성
- 비교 조건의 종류와 효율성
- ex. SELECT * FROM table where c1='...' AND c2 <= '...'
  - 인덱스가 (c1, c2)으로 설정된 경우
    - 인덱스는 정렬되어 있으므로 인덱스만 읽으면 됨
    - 이를 **작업 범위 결정 조건**이라 함
  - 인덱스가 (c2, c1)으로 설정된 경우
    - c2 <= '...'에 해당되는 인덱스를 모두 읽은 후 필요 없는 것을 버림
    - 이름 필터링이라 함
- 인덱스 가용성
  - B-Tree 인덱스는 왼쪽 -> 오른쪽 칼럼 기준으로 정렬됨. 다중 칼럼 인덱스도 동일함
  - 그러므로, 인덱스 및 조회 조건에 따라 효율적으로 검색하지 못할 수 있음(인덱스 풀 스캔)
- 가용성과 효율성 판단
  - 아래 조건은 작업 범위 결정 조건으로 조회 불가
    - !, NOT 연산자로 조회
    - 뒷부분이 일치하는 문자열 조회('%??')
    - SUBSTRING 처럼 인덱스 칼럼 변경 후 비교
    - 데이터 타입과 다르게 비교(묵시적 타입 변경이 발생하는 경우)
    - 문자열 데이터 타입의 콜레이션이 다른 경우
    - Non-Deterministic 속성의 스토어드 함수(ex. now())가 비교 조건인 경우
  - 효율적인 인덱스 사용이 가능한 케이스(ex. INDEX ix (c1, c2, c3)
    - 모든 칼럼까지 = 또는 IN으로 비교
    - 첫번째 칼럼인 c1 칼럼에 대해 =, IN, >, <, LIKE, '%??' 비교
### 5.4 R-Tree 인덱스
- MySQL 공간 정보 검색을 위한 인덱스

### 5.5 전문 검색 인덱스
- 문서 내용 전체를 인덱스화하여 저장한 후, 특정 키워드가 포함된 문서를 검색하는 것을 전문 검색이라 함
- 여기에 사용되는 인덱스가 전문 검색 인덱스
#### 5.5.1 인덱스 알고리즘
- 어근 분석 알고리즘
  - 불용어 처리 : 가치 없는 단어 필터링하여 제거
  - 어근 분석 : 단어의 뿌리인 원형을 찾는 과정(MeCab 모듈)
- n-gram 알고리즘
  - 키워드 검색을 위한 인덱싱 알고리즘
  - 본문에서 2글자씩 키워드를 쪼개어 토큰화하여 인덱싱
    - ex. 2-gram : That -> Th/ha/at
    - 토큰 중 불용어와 일치하는 것은 필터링함

### 5.6 함수 기반 인덱스
- MySQL 8.0 이상 버전부터 지원함
- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스가 필요한 경우에 사용함
#### 5.6.1 가상 칼럼을 이용한 인덱스
- 아래와 같은 방법으로 가상 칼럼에 대한 인덱스 생성이 가능함
```sql
ALTER TABLE member
ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL
ADD INDEX ix_full_name (full_name);
```
- 단점 : 테이블에 칼럼을 새로 생성하는 것과 동일한 효과임
#### 5.6.2 함수를 이용한 인덱스
- 아래와 같은 방법으로 함수를 이용한 인덱스 생성이 가능함
```sql
ALTER TABLE member
ADD INDEX ix_full_name ((CONCAT(first_name, ' ', last_name)));
```
- 인덱스 생성 후, 명시된 표현식을 그대로 조건으로 사용
- WHERE CONCAT(first_name, ' ', last_name) = '...'
- 테이블 구조를 변경하지 않음

### 5.7 멀티 벨류 인덱스
- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 인덱스
- JSON 타입의 칼럼에 사용됨(동일한 인덱스에서, 여러개의 키가 하나의 레코드를 참조함)

### 5.8 클러스터링 인덱스
- 유사한 기본 키를 가진 테이블 레코드를 묶어서 하나의 페이지에 저장하고











