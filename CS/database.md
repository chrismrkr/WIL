# 데이터베이스

## 1. 데이터베이스 개념 및 용어

### 1.1 키(Key)

키는 유일성을 만족하는 테이블의 속성이다.

+ 후보키 : 유일성과 최소성을 만족하는 키
+ 기본키 : 후보키들 중 하나
+ 슈퍼키 : 유일성만 만족하는 키

### 1.2 키 제약조건(Key Constraints)

키를 구성하는 속성들 중 일부분이 키가 되어서는 안된다는 조건

### 1.3 참여 제약조건

+ 부분참여 : 모든 엔티티는 관계를 맺지 않아도 된다.
+ 전체참여 : 모든 엔티티는 관계를 맺어야 한다.

### 1.4 약개체

다른 개체(테이블)와 전체 참여제약조건을 갖고, 독립적으로 존재할 수 없는 개체

### 1.5 무결성 제약조건

DB의 일관성과 정확성을 보장하기 위한 조건

+ 개체 무결성 : 기본키는 Null이 아니고 중복되어서도 안된다.
+ 참조 무결성 : 외래키는 Null이거나 참조 개체의 기본키여야 한다.

### 1.6 외래키 제약조건

개체 간 관계에 거는 조건이고 자기 참조도 가능하다.


### 1.7 데이터 모델링

데이터 모델링이란 비즈니스 로직을 추상화, 단순화, 명확화하는 작업이다.

데이터 모델링의 3요소

+ 무엇을 모델링? 어떤 비즈니스를 모델링? : Entity 설계
+ 어떤 속성을 갖는가? : Attribute 결정
+ 어떤 관계를 갖는가? : Relation 결정

데이터 모델링시 중복, 비일관성, 비유연성을 피해야한다.

### 1.8 데이터 스키마구조 3단계

스키마란 Entity, Attribute, Relation을 기술한 내용이다.

+ 외부스키마(사용자 뷰) : 개개인 사용자 입장에서 스키마를 정의
+ 개념스키마(전체 뷰) : 종합적인 관점에서의 스키마 정의(무결성 제약조건 결정)
+ 내부스키마(전체 스키마) : 물리적인 저장방식을 정의

### 1.9 Entity 분류

<b>유형 및 무형에 따른 분류</b>

+ 유형엔티티 : 물리적 형태가 있는 엔티티(ex. 회원, 상품)
+ 개념엔티티 : 물리적 형태는 없으나 관리해야할 엔티티(ex. 부서, 팀)
+ 사건엔티티 : 엔티티의 action(ex. 주문, 청구)

<b>발생 시점에 따른 분류</b>

+ 기본엔티티 : 원래 존재하고 독립 생성되는 엔티티(ex. 회원)
+ 중심엔티티 : 기본엔티티로부터 발생하는 엔티티(ex. 주문)
+ 행위엔티티 : 2개 이상의 엔티티로부터 발생하는 엔티티

### 1.10 식별관계와 비식별관계

+ 식별관계 : 부모 Entity로 부터 받은 식별자를 자식 Entity의 식별자로 사용
+ 비식별관계 : 부모로부터 받은 식별자를 자식엔티티에서의 식별자로 사용하지 않고 일반 속성으로만 사용함. 그러므로, 부모로부터 받은 식별자는 외래키로 관리된다.

비식별관계로 나타내는 경우는 아래와 같다.
+ 1. 부모 없는 자식 엔티티가 존재할 수 있는 경우
+ 2. 엔티티 생명주기가 부모 엔티티와 다른 경우
+ 3. 자식 엔티티에서의 별도의 식별자가 필요하다고 판단되는 경우
+ 4. 주식별자의 속성이 너무 많아서 쿼리 성능이 악화될 가능성이 있는 경우

비식별 관계는 자식에서 부모를 찾아갈 때, 항상 Join이 필요하다는 단점이 있다.

***

## 2. 인덱스(Index)

인덱스(index)란 데이터베이스 디스크에서 페이지(블록) 단위로 데이터를 더 효율적으로 읽기 위해 존재하는 자료구조이다.

### 2.1 파일구조

디스크에 저장된 파일 구조는 아래와 같다.

+ 1. 랜덤 힙 : 레코드를 단순히 쌓는 구조
+ 2. 정렬 파일 : 키를 통해 정렬해서 담는 구조. 페이지가 꽉 차면 문제가 된다.
+ 3. clustered 파일 : 데이터 순서와 인덱스 순서가 일치하는 파일 구조
+ 4. unclustered 파일 : 데이터 순서와 인덱스 구조가 일치하지 않는 파일

그러므로, clustered index와 unclustered index의 차이는 파일 구조와 인덱스의 순서 차이이다.

### 2.2 트리 구조 인덱스

트리 구조 인덱스는 범위 탐색에서 유리하다.

#### 2.2.1 ISAM

정적 index 트리이다. index에 맞추어 페이지를 참조하며 단말노드가 다 차면 overflow chain을 활용한다.

#### 2.2.2 B-트리

balanced tree이고 노드(key)마다 rid를 갖는다. 이진 탐색 트리와 다소 유사하다.

**삽입 과정**

1. 삽입할 bucket 위치를 조회한다.
2. 삽입 후 bucket의 용량이 차수보다 커졌다면, bucket의 중간 값을 부모 bucket 노드로 push하고 해당 bucket을 분리한다.
==> 만약 부모 bucket으로 push된 후, 부모 bucket 용량도 차수보다 커졌다면 2번 과정을 반복한다.

**삭제 과정**

1. 삭제 값이 있는 bucket 위치를 조회한다.
2. 삭제한다.
3-1 단말 노드 bucket인 경우) 만약 bucket이 비게 되면, 부모 노드가 그 자리를 대체하고, 부모 노드가 가리키고 있던 두 Bucket을 병합한다.
==> 병합 후, Bucket 용량이 차수보다 커졌다면, 이전과 동일한 Bucket 분할과정을 거친다. 

3-2 단말노드 bucket이 아닌 경우) 
만약,  삭제하는 노드 또는 그것의 자식 bucket 용량이 2개 이상이라면, 해당 subtree의 왼쪽 자식의 가장 오른쪽 자손, 또는 오른쪽 자식의 가장 왼쪽 자손을 옮긴다.
그 후, 자손 bucket이 비게 된다면 3-1을 반복한다.

만약 삭제하는 노드와 그것의 자식 bucket 용량이 모두 1개라면, 삭제하고 자식 노드들을 병합한다.
그리고, 삭제한 노드의 bucket을 가리키던 부모 노드가 이들의 부모가 된다.
부모 노드는 본인의 오른쪽 자식 bucket과 합쳐진다. 합쳐진 후 bucket 용량이 꽉 찼다면, 2번 과정을 반복한다.

#### 2.2.3 B+ 트리

balanced 트리이고 rid-list를 가진 노드는 오로지 단말노드이다. 단말 노드끼리는 linkedList로 연결되어 있다.

**삽입 과정**

1. 삽입 위치를 찾는다.
2. 삽입
3. 삽입한 후 bucket이 꽉 찼다면, bucket의 중간 값을 copy-up 하여 부모 bucket에 전달한 후 분할한다.
==> 만약 부모 bucket도 꽉 찼다면, 분할한다.

**삭제 과정**
만약 차수(d)가 2라면, bucket의 용량은 2 <=  <= 4를 유지해야 한다.

Case1. 삭제해도 하한 밑으로 떨어지지 않는 경우

bucket에서 노드를 삭제하면 된다.

Case2. 삭제하면 하한 밑으로 떨어지나 형제 버켓으로 부터 재분배받을 수 있는 경우

형제 버켓으로부터 노드를 재분배 받는다. 그리고 부모 값을 조정한다.

Case3. 삭제하면 하한 밑으로 떨어지고 재분배도 불가능한 경우

인접 노드와 병합한 후, 부모 bucket의 포인터를 변경한다.


### 2.3 해시 기반 인덱스

해시 기반 인덱스는 동등 탐색에 유리하나 범위 탐색에 불리하다.

#### 2.3.1 정적 해싱
#### 2.3.2 확장성 해싱

***

## 3. 트랜잭션 관리

트랜잭션이란 DB와 관련하여 발생하는 연속된 하나의 작업을 의미한다.

### 3.1 트랜잭션의 특징

+ Atomicity : 원자성, 한 트랜잭션 내의 작업은 모두 실행되어야 한다. 그렇지 않으면 실행하면 안된다.
+ Consistency : 일관성, DB의 데이터가 일관되게 유지되어야 한다.
+ Isolation : 고립성, 한 트랜잭션은 다른 트랜잭션에 영향을 주어서는 안된다.
+ Duration : 영구성, 한번 저장된 데이터는 추가 작업이 없으면 계속 유지되어야 한다.

### 3.2 비관적 락 기법

트랜잭션 충돌은 반드시 일어난다는 가정 하에, transaction lock을 관리하는 기법이다.

비관적 락 기법은 Read와 Write 모두에 대해서 exclusive lock을 유지한다. 이러면 트랜잭션 충돌은 발생하지 않는다.

그러나, Dead Lock이 발생할 수 있다. 아래의 예를 보면 T1, T2는 DeadLock 상태가 된다.

T1 : R(A)                           W(B) Commit           

T2 :            R(B) W(A) Commit

만약 Read 작업에 대해서 Lock을 사용하지 않았다면 DeadLock을 막을 수 있었다. 그러나, dirty-read, non-repeatable read, phantom read 문제가 발생할 수 있다.

### 3.3 Isolation level 조절 정책

Read에 대해서 exclusive lock을 하지 않으면 isolation에 위배될 수 있다. 그러므로, 고립성을 관리하는 정책이 필요하다. 

### 3.3.1 read uncommited

commit되지 않은 데이터도 read 작업에 반영되는 것이다. 여기서는 dirty-read, non-repeadtable read, phantom read 3가지 문제 모두 존재한다.

dirty-read 예제는 다음과 같다. T1의 read(A) 결과가 다르다.

<p> T1:            read(A)                read(A) </p>

<p>T2: Write(A)              RollBack  </p>

### 3.3.2 read commited

**commit되지 않은 데이터는 undo 로그에서 값을 가져온다는 정책이다.** 그러므로, 위의 dirty read는 막을 수 있다.

T1: 
T2: 

***

## 4. 정규화와 이상현상





